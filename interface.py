import discordfrom game_runner import new_game, jumpstartimport asyncioclient = discord.Client()@client.eventasync def on_ready():    print("PokerBot ready")@client.eventasync def on_message(message):    if message.author == client.user:        return    if message.content == '':        return    if message.content[0] != '!':        return    channel = message.channel    cmd, *args = [s.lower() for s in message.content[1:].split()]    if cmd == "help":        await channel.send("```!newgame - start a new game```")    if cmd == "newgame":        print("Started new game")        await new_game(message.author, channel)    if cmd == "resume":        print("Jumpstarted")        await jumpstart(channel)    if cmd == "test":        print('yeet')        host = message.author        def check(msg):            print(msg.author.id, host.id)            return msg.author == host        msg = await client.wait_for('message', check=check)        print(msg.content)async def reaction_menu(options_dict, player, channel):    menustring = ''.join([f"{a}:  {b},  " for a, b in options_dict.items()])    sent_message = await channel.send(menustring)    # await channel.send(sent_message.id)  # just for testing    for emoji in options_dict.keys():        await sent_message.add_reaction(emoji)    def check4(rctn, usr):        return player == usr and rctn.emoji in options_dict and rctn.message.id == sent_message.id        # checks for correct player, valid reaction (aka no new emoji) and that reaction is to this message, resp.    reaction, user = await client.wait_for('reaction_add', check=check4)    return options_dict[reaction.emoji]async def reaction_menu_replyv(options_dict, player, sent_message):  # TODO: probably rename this (or replace previous)    # menustring = ''.join([f"{a}:  {b},  " for a, b in options_dict.items()])    # sent_message = await channel.send(menustring)    # await channel.send(sent_message.id)  # just for testing    for emoji in options_dict.keys():        await sent_message.add_reaction(emoji)    def check4(rctn, usr):        return player == usr and rctn.emoji in options_dict and rctn.message.id == sent_message.id        # checks for correct player, valid reaction (aka no new emoji) and that reaction is to this message, resp.    reaction, user = await client.wait_for('reaction_add', check=check4)    return options_dict[reaction.emoji]# async def reaction_poll(options_dict, players, channel):#     menustring = ''.join([f"{a}:  {b},  " for a, b in options_dict.items()])#     sent_message = await channel.send(menustring)##     await channel.send(sent_message.id)  # just for testing#     for emoji in options_dict.keys():#         await sent_message.add_reaction(emoji)##     def check5(rctn, usr):#         return usr in players and rctn.emoji in options_dict and rctn.message.id == sent_message.id##     begin = time.time()#     while time.time() - begin < 60:#         try:#             reaction, user = await client.wait_for('reaction_add', check=check5, timeout=30)#         except TimeoutError:#             continue##     reactions = sent_message.reactions#     return_dict = {}#     for r in reactions:#         return_dict[options_dict[r.emoji]] = await r.users().flatten()# class ButtonTracker:#     def __init__(self, message, options_dict, default, player, channel):#         self.options_dict = options_dict#         self.default = default#         self.channel = channel#         self.player = player#         sent_message = await channel.send(message)#         self.message_id = sent_message.id#         for emoji in options_dict.keys():#             await sent_message.add_reaction(emoji)##     async def read(self):#         refreshed_message = await (self.channel).fetch_message(self.message_id)  # update message#         reactions = [r async for r in refreshed_message.reactions if self.player in r.users()]#         if len(reactions) != 1:#             return self.default##         else:#             return self.options_dict[reactions[0].emoji]    async def button(message, players, channel, timeout=20):    sent_message = await channel.send(message)    await sent_message.add_reaction("ðŸ”˜")    await asyncio.sleep(timeout)    refreshed_message = await sent_message.channel.fetch_message(sent_message.id)  # update message    reactions = refreshed_message.reactions    reacted_players = []    for r in reactions:        if r.emoji == 'ðŸ”˜':            ids = [u.id for u in await r.users().flatten()]            reacted_players = [p for p in players if p.id in ids]            break    return reacted_playersasync def wait_for_msg(channel, check=lambda msg: True):    def total_check(msg):        # print('total_check',check(msg), msg.channel == channel)        return check(msg) and msg.channel == channel    return await client.wait_for('message', check=total_check)# async def prompt(channel, player):#     def check(msg):#         return msg.author == player and msg.channel == channel#     return await client.wait_for('message')def run():    with open("./files/token.txt", 'r') as token_file:        token = token_file.read()    client.run(token)