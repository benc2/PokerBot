import discordfrom game_runner import new_game, jumpstart, moderator, user_set_from_message, set_moderatorsimport asyncioclient = discord.Client()@client.eventasync def on_ready():    print("PokerBot ready")@client.eventasync def on_message(message):    if message.author == client.user:        return    if message.content == '':        return    if message.content[0] != '!':        return    channel = message.channel    cmd, *args = [s.lower() for s in message.content[1:].split()]    if cmd == "help":        await channel.send("```!newgame - start a new game```")    if cmd == "newgame":        print("Started new game")        await new_game(message.author, channel)    if cmd == "resume":        print("Jumpstarted")        await jumpstart(channel)    if cmd == "test":        print('yeet')        host = message.author        def check(msg):            print(msg.author.id, host.id)            return msg.author == host        msg = await client.wait_for('message', check=check)        print(msg.content)    if cmd == "mod":        moderators = user_set_from_message(message)        set_moderators(moderators)async def reaction_menu(options_dict, player, channel):    menustring = ''.join([f"{a}:  {b},  " for a, b in options_dict.items()])    sent_message = await channel.send(menustring)    # await channel.send(sent_message.id)  # just for testing    for emoji in options_dict.keys():        await sent_message.add_reaction(emoji)    def check(rctn, usr):        return player == usr and rctn.emoji in options_dict and rctn.message.id == sent_message.id        # checks for correct player, valid reaction (aka no new emoji) and that reaction is to this message, resp.    reaction, user = await client.wait_for('reaction_add', check=check)    return options_dict[reaction.emoji]async def reaction_menu_replyv(options_dict, player, sent_message):  # TODO: probably rename this (or replace previous)    # menustring = ''.join([f"{a}:  {b},  " for a, b in options_dict.items()])    # sent_message = await channel.send(menustring)    # await channel.send(sent_message.id)  # just for testing    for emoji in options_dict.keys():        await sent_message.add_reaction(emoji)    def check(rctn, usr):        return player == usr and rctn.emoji in options_dict and rctn.message.id == sent_message.id        # checks for correct player, valid reaction (aka no new emoji) and that reaction is to this message, resp.    reaction, user = await client.wait_for('reaction_add', check=check)    return options_dict[reaction.emoji]# async def reaction_poll(options_dict, players, channel):#     menustring = ''.join([f"{a}:  {b},  " for a, b in options_dict.items()])#     sent_message = await channel.send(menustring)##     await channel.send(sent_message.id)  # just for testing#     for emoji in options_dict.keys():#         await sent_message.add_reaction(emoji)##     def check5(rctn, usr):#         return usr in players and rctn.emoji in options_dict and rctn.message.id == sent_message.id##     begin = time.time()#     while time.time() - begin < 60:#         try:#             reaction, user = await client.wait_for('reaction_add', check=check5, timeout=30)#         except TimeoutError:#             continue##     reactions = sent_message.reactions#     return_dict = {}#     for r in reactions:#         return_dict[options_dict[r.emoji]] = await r.users().flatten()class ButtonTracker:  # TODO: vote, choice and reaction used interchangeably, make consistent    def __init__(self, options_dict, sent_message,  user, name=None):        self.options_dict = options_dict        self.sent_message = sent_message        self.channel = self.sent_message.channel        self.user = user        self.message_id = sent_message.id        self.name = name        self.options_dict = options_dict    async def read(self, multiple_choice_mode="none", default=None):        refreshed_message = await self.channel.fetch_message(self.message_id)  # update message        reactions = [r for r in refreshed_message.reactions if self.user in await r.users().flatten()]  # oof, inefficient        if len(reactions) == 0:  # if no vote was cast            return default        elif len(reactions) > 1:  # if multiple votes were cast            if multiple_choice_mode == "default":                return default            elif multiple_choice_mode == "none":                return None            elif multiple_choice_mode == "return_all":                return [self.options_dict[r.emoji] for r in reactions]            else:                raise ValueError(f"Invalid multiple choice mode \"{multiple_choice_mode}\". "                                 "Options are: default, none, return_all")        else:  # if just 1 vote was cast            return self.options_dict[reactions[0].emoji]    async def clear_votes(self):        refreshed_message = await self.channel.fetch_message(self.message_id)        for reaction in refreshed_message.reactions:            users = await reaction.users().flatten()            for user in users:                if user != client.user:                    await reaction.remove(user)    async def wait_for_reaction(self, check=lambda x, y: True):        message = await self.channel.fetch_message(self.message_id)        def total_check(reaction, user):            return reaction.message.id == message.id and user == self.user and reaction.emoji in self.options_dict\                and check(reaction, user)        response = await client.wait_for('reaction_add', check=total_check)        return self.options_dict[response[0].emoji]async def button_tracker_menu(options_dict, sent_message, user, **kwargs):    for emoji in options_dict.keys():        await sent_message.add_reaction(emoji)    button_tracker = ButtonTracker(options_dict, sent_message, user, **kwargs)    return button_trackerasync def button(message, players, channel, timeout=20):    sent_message = await channel.send(message)    await sent_message.add_reaction("ðŸ”˜")    await asyncio.sleep(timeout)    refreshed_message = await sent_message.channel.fetch_message(sent_message.id)  # update message    reactions = refreshed_message.reactions    reacted_players = []    for r in reactions:        if r.emoji == 'ðŸ”˜':            ids = [u.id for u in await r.users().flatten()]            reacted_players = [p for p in players if p.id in ids]            break    return reacted_playersasync def wait_for_msg(channel, check=lambda msg: True):    def total_check(msg):        return check(msg) and msg.channel == channel    return await client.wait_for('message', check=total_check)# async def prompt(channel, player):#     def check(msg):#         return msg.author == player and msg.channel == channel#     return await client.wait_for('message')def run():    with open("./files/token.txt", 'r') as token_file:        token = token_file.read()    client.run(token)