import discordfrom current_build.game_runner import new_game, jumpstartimport asyncioclient = discord.Client()@client.eventasync def on_message(message):    if message.author == client.user:        return    if message.content == '':        return    if message.content[0] != '!':        return    channel = message.channel    cmd, *args = [s.lower() for s in message.content[1:].split()]    if cmd == "help":        await channel.send("```!newgame - start a new game```")    if cmd == "newgame":        print("Started new game")        await new_game(message.author, channel)    if cmd == "resume":        print("Jumpstarted")        await jumpstart(channel)    if cmd == "test":        print('yeet')        host = message.author        def check(msg):            print(msg.author.id, host.id)            return msg.author == host        msg = await client.wait_for('message', check=check)        print(msg.content)async def reaction_menu(options_dict, player, channel):    menustring = ''.join([f"{a}:  {b},  " for a, b in options_dict.items()])    sent_message = await channel.send(menustring)    # await channel.send(sent_message.id)  # just for testing    for emoji in options_dict.keys():        await sent_message.add_reaction(emoji)    def check4(rctn, usr):        return player == usr and rctn.emoji in options_dict and rctn.message.id == sent_message.id        # checks for correct player, valid reaction (aka no new emoji) and that reaction is to this message, resp.    reaction, user = await client.wait_for('reaction_add', check=check4)    return options_dict[reaction.emoji]# async def reaction_poll(options_dict, players, channel):#     menustring = ''.join([f"{a}:  {b},  " for a, b in options_dict.items()])#     sent_message = await channel.send(menustring)##     await channel.send(sent_message.id)  # just for testing#     for emoji in options_dict.keys():#         await sent_message.add_reaction(emoji)##     def check5(rctn, usr):#         return usr in players and rctn.emoji in options_dict and rctn.message.id == sent_message.id##     begin = time.time()#     while time.time() - begin < 60:#         try:#             reaction, user = await client.wait_for('reaction_add', check=check5, timeout=30)#         except TimeoutError:#             continue##     reactions = sent_message.reactions#     return_dict = {}#     for r in reactions:#         return_dict[options_dict[r.emoji]] = await r.users().flatten()async def button(message, players, channel, timeout=20):    sent_message = await channel.send(message)    await sent_message.add_reaction("ðŸ”˜")    await asyncio.sleep(timeout)    refreshed_message = await sent_message.channel.fetch_message(sent_message.id)  # update message    reactions = refreshed_message.reactions    reacted_players = []    for r in reactions:        if r.emoji == 'ðŸ”˜':            ids = [u.id for u in await r.users().flatten()]            reacted_players = [p for p in players if p.id in ids]            return reacted_players    print("NO Reactions on button?")    return []async def wait_for_msg(channel, check=lambda msg:True):    def total_check(msg):        # print('total_check',check(msg), msg.channel == channel)        return check(msg) and msg.channel == channel    return await client.wait_for('message', check=total_check)# async def prompt(channel, player):#     def check(msg):#         return msg.author == player and msg.channel == channel#     return await client.wait_for('message')def run():    client.run("NjQ0NTcxMzYxNTc4MDU3NzI4.Xc1-BQ.ohz2yxA1TwEOCyCwawCUu9YUOug")